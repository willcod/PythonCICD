# Reconstraction code for providing grpc interfaces
import re
import time
from concurrent import futures
from axchange.data import Trace
from axchange.proxy import TraceFromScope
# gRPC
import grpc
from saxcscontroller.slrt.balancerxry import *
from saxcscontroller.slrt.balancexy import *
from saxcscontroller.slrt.stage import *
from saxcscontroller.slrt.stageaxis import *
from saxcscontroller.slrt.stagehbridge import *

import hashlib
import saxcs_diagnostic_pb2
import saxcs_diagnostic_pb2_grpc
from sinewave_balance import DiagClass
import logging

import numpy as np
# Import the files which generated by grpc tools

'''
Class for tuning balanceXY and balanceRxRy
'''
class SaxcsDiagonstic(saxcs_diagnostic_pb2_grpc.SaxcsDiagonstic):
    def __init__(self) -> None:
        # Initialize an object
        logging.basicConfig(level=logging.DEBUG,
                            format='%(asctime)s %(name)-12s %(levelname)-8s %(message)s',
                            datefmt='%m-%d %H:%M',
                            filename='SAXCS_Diagnostic.log',
                            filemode='w')
        self.logger = logging.getLogger('Saxcs Diagnostic Test:')
        self.upss_diag = DiagClass()
        self.pi = 3.1415926
        self.xsinewave_set = False           # Used to check if sinewave injection can be enabled or not
        self.ysinewave_set = False 
        self.xypos_set = False
        self.XPos = 0
        self.YPos = 0
        self.holdtime = 5
        self.AmpU = 0
        self.FreqU = 0
        self.FreqV = 0
        self.AmpV = 0
        self.correct_passwdx = False
        self.correct_passwdy = False
        self.xffdgain_set = False
        self.yffdgain_set = False
        self.rxffdgain_set = False
        self.ryffdgain = False
        self.MappingXParam_Set = False
        self.MappingYParam_Set = False
        self.MoveXToIFMTar = False
        self.MoveYToIFMTar = False
        self.stoprecord = False
        # Define signals for tuning balance and monitor stage status
        self.file_name = 'Upss_Diag_'                 # Define file name and position
        self.path = 'C:\\WWW'
        self.signals = ['Stage/Monitor/U/PosAct',
                        'Stage/Monitor/VRw/V/PosAct',
                        'BalanceXY/Monitor/PosAvgX',
                        'BalanceXY/Monitor/PosAvgY',
                        'BalanceXY/Monitor/BalanceFfwd/BalanceForce_Left',
                        'BalanceXY/Monitor/BalanceFfwd/BalanceForce_Right',
                        'BalanceXY/Monitor/BalanceFfwd/BalanceForce_Back',
                        'BalanceXY/Monitor/BalanceFfwd/BalanceForce_Front',
                        'BalanceXY/Monitor/MonitorLeft/MeasurementSystem/EcsPositionFilt',
                        'BalanceXY/Monitor/MonitorLeft/BalanceGain',
                        'BalanceXY/Monitor/MonitorRight/MeasurementSystem/EcsPositionFilt',
                        'BalanceXY/Monitor/MonitorRight/BalanceGain',
                        'BalanceXY/Monitor/MonitorBack/MeasurementSystem/EcsPositionFilt',
                        'BalanceXY/Monitor/MonitorBack/BalanceGain',
                        'BalanceXY/Monitor/MonitorFront/MeasurementSystem/EcsPositionFilt',
                        'BalanceXY/Monitor/MonitorFront/BalanceGain',
                        'BalanceRxRy/Monitor/PosErrRx',
                        'BalanceRxRy/Monitor/PosErrRy',
                        'BalanceRxRy/Monitor/MeasurementSystemLeftBack/EcsPositionFilt',
                        'BalanceRxRy/Monitor/MeasurementSystemRightCenter/EcsPositionFilt',
                        'BalanceRxRy/Monitor/MeasurementSystemLeftFront/EcsPositionFilt',
                        'BalanceRxRy/Monitor/RxGain/LeftBack',
                        'BalanceRxRy/Monitor/RxGain/RightBack',
                        'BalanceRxRy/Monitor/RxGain/LeftFront',
                        'BalanceRxRy/Monitor/RxGain/RightFront',
                        'BalanceRxRy/Monitor/RyGain/LeftBack',
                        'BalanceRxRy/Monitor/RyGain/LeftFront',
                        'BalanceRxRy/Monitor/RyGain/RightBack',
                        'BalanceRxRy/Monitor/RyGain/RightFront',
                    ]
        self.mapping_signal = ['Stage/Monitor/U/PosAct',
                               'Stage/Monitor/U/PosActComp',
                               'Stage/Monitor/U/SetPoint/PosSetp',
                               'Stage/Monitor/U/SetPoint/AccSetp',
                               'Stage/Monitor/U/SetPoint/VelSetp',
                               'Stage/Monitor/U/Controller/PosErrMotor',
                               'Stage/Monitor/VRw/V/PosAct',
                               'Stage/Monitor/VRw/V/PosActComp',
                               'Stage/Monitor/VRw/V/SetPoint/PosSetp',
                               'Stage/Monitor/VRw/V/SetPoint/VelSetp',
                               'Stage/Monitor/VRw/V/SetPoint/AccSetp',
                               'Stage/Monitor/VRw/V/Controller/PosErrMotor',
                               'Stage/Monitor/VRw/Rw/PosAct',
                               'Stage/Monitor/VRw/Rw/PosActComp',
                               'Stage/Monitor/VRw/Rw/',
                            ]

    def CleanMark(self):
        self.xsinewave_set = False           # Used to check if sinewave injection can be enabled or not
        self.ysinewave_set = False 
        self.xypos_set = False
        self.XPos = 0
        self.YPos = 0
        self.holdtime = 5
        self.AmpU = 0
        self.FreqU = 0
        self.FreqV = 0
        self.AmpV = 0
        self.xffdgain_set = False
        self.yffdgain_set = False
        self.rxffdgain_set = False
        self.ryffdgain = False
        self.MappingXParam_Set = False
        self.MappingYParam_Set = False
        self.MoveXToIFMTar = False
        self.MoveYToIFMTar = False
    
    def file_md5(self, file_path):
        with open(file_path, 'rb') as f:
            md5obj = hashlib.md5()
            md5obj.update(f.read())
            _hash = md5obj.hexdigest()
        return str(_hash).upper()

    # Define a sinewave parameters check method    
    def ParametersCheck(self, ChoseParam, SinewaveAmp, SinewaveFreq):
        '''
        Function: Used to check the sinewave parameters are safety or not
        ChoseParam = 0,1 # 0: X Stage, 1: Y Stage
        SinewaveAmp: The Amplitude of chosed stage
        SinewaveFreq: The Frequency of chosed stage
        '''
        self.logger.debug("Checking parameters of sinewave: SinewaveAmp={0}, SinewaveFreq={1}".format(SinewaveAmp, SinewaveFreq))
        RequestVelocity = 2 * self.pi * SinewaveFreq * SinewaveAmp
        RequestAcceleration = 2 * self.pi * RequestVelocity
        velocitylimited = True
        accelerationlimited = True
        self.xsinewave_set = False           # Used to check if sinewave injection can be enabled or not
        self.ysinewave_set = False 
        if ChoseParam == 0:                 # X Stage
            self.logger.debug("Checking X stage parameters")
            if RequestVelocity > self.upss_diag.stage.U.Tuning.SetpointBoundsNominal.Velocity.value:

                velocitylimited = False         # Set velocity out of rage
            elif RequestAcceleration > self.upss_diag.stage.U.Tuning.SetpointBoundsNominal.Acceleration.value:
                accelerationlimited = False     # Set acceleration out of rage
            else:
                self.FreqU = SinewaveFreq
                self.AmpU = SinewaveAmp
                self.RisingSlewRateU = 0.1 * SinewaveAmp
                self.xsinewave_set = velocitylimited and accelerationlimited
            return self.xsinewave_set
        elif ChoseParam == 1:
            self.logger.debug("Checking X stage parameters")
            if RequestVelocity > self.upss_diag.stage.VRw.Tuning.V.SetpointBoundsNominal.Velocity.value:
                velocitylimited = False         # Set velocity out of rage
            elif RequestAcceleration > self.upss_diag.stage.VRw.Tuning.V.SetpointBoundsNominal.Acceleration.value:
                accelerationlimited = False     # Set acceleration out of rage
            else:
                self.FreqV = SinewaveFreq
                self.AmpV = SinewaveAmp
                self.RisingSlewRateV = 0.1 * SinewaveAmp
                self.ysinewave_set = velocitylimited and accelerationlimited
            return self.ysinewave_set
        else:
            return False

    def GetOrgAlignEncRaw(self, request, context):
        try:
            self.logger.info("Get Y left and Y right encoder raw data")
            YL_Enc = self.upss_diag.stage.VRw.Monitor.Hardware.V1.DS402driveEncoderPosRaw.value
            YR_Enc = self.upss_diag.stage.VRw.Monitor.Hardware.V2.DS402driveEncoderPosRaw.value
            return saxcs_diagnostic_pb2.YlYrEncReply(yl_enc_raw=YL_Enc, yr_enc_raw=YR_Enc)
        except grpc.RpcError as e:
            raise e

    def SetOrgAlignDelta(self, request, context):
        try:
            self.logger.info("Set encoder data to {}".format(request.enc_raw_delta))
            if abs(request.enc_raw_delta) <= 10000000:
                return saxcs_diagnostic_pb2.ResultReply(result_succeed = True)
            else:
                return saxcs_diagnostic_pb2.ResultReply(result_succeed = False)
        except grpc.RpcError as e:
            raise e

    def SetXSinewave(self, request, context):
        ''' 
        Check the input parameters and set sinewave frequency and amplitude 
        Input: Frequency and Amplitude of sinewave injection
        Return: Sinwave parameters have been set(True) or not(False)
        '''
        try:
            self.logger.info("Setting X stage sinewave.")
            if self.ParametersCheck(0, request.x_sinvewave_amp, request.x_sinvewave_freq):
                self.logger.info("X sinewave parameters checked")
                return saxcs_diagnostic_pb2.ResultReply(result_succeed = self.xsinewave_set)
        except grpc.RpcError as e:
            raise e

    def SetXFFDGain(self, request, context):
        '''
        Set Feedforward gain range for tuning
        : request.XInitialGain: Set balance tuning first gain
        : request.XMaxGain: Set the feedforward gain maximum value
        : request.XGainStep
        '''
        try:
            self.logger.info("Setting Balance X tunging FFD Gain")
            self.xinitial_gain = request.x_initial_gain
            self.xmax_gain = request.x_max_gain
            self.xgain_step = request.x_gain_step
            logging.debug("InitialGain={0}, MaxGain={1}, GainStep={2}".format(self.xinitial_gain, self.xmax_gain, self.xgain_step))
            self.xffdgain_set = True
            return saxcs_diagnostic_pb2.ResultReply(result_succeed = self.xffdgain_set)
        except grpc.RpcError as e:
            raise e
    
    def SetXYPosition(self, request, context):
        '''
        Set XY tuning position, different gain may be generate
        : request.x_act_pos: Set X stage pos
        : request.y_act_pos: Set Y stage pos
        '''
        try:
            self.logger.info("Setting stage position")
            if ((self.AmpU + request.x_act_pos) > 0.2) or ((self.AmpU - request.x_act_pos) < -0.2):
                self.logger.debug("Stage X will move out of the stroke")
                return saxcs_diagnostic_pb2.ResultReply(result_succeed = False)
            elif((self.AmpV + request.y_act_pos) > 0.2) or ((self.AmpV - request.y_act_pos) < -0.2):
                self.logger.debug("Stage Y will move out of the stroke")
                return saxcs_diagnostic_pb2.ResultReply(result_succeed = False)
            else:
                self.XPos = request.x_act_pos
                self.YPos = request.y_act_pos
                self.xypos_set = True
                self.logger.info("Stage position set")
                return saxcs_diagnostic_pb2.ResultReply(result_succeed = self.xypos_set)
        except grpc.RpcError as e:
            raise e

    def SetXBestGain(self, request, context):
        '''
        Set the best gain of current tuning
        : request.XBetGain: The best gain was found in current tuning loop 
        TODO: The best gain need to save in firmware(Startup software)
        '''
        try:
            self.logger.info("Setting Balance X best feedforward gain")
            self.upss_diag.balancexy.Tuning.TuningBalanceFfwd.BalanceParamsX.BalanceForceGain_Back.value = request.x_best_gain
            self.upss_diag.balancexy.Tuning.TuningBalanceFfwd.BalanceParamsX.BalanceForceGain_Front.value = request.x_best_gain
            self.logger.info("Balance X gain set")
            return saxcs_diagnostic_pb2.ResultReply(result_succeed = True)
        except grpc.RpcError as e:
            raise e

    def XSinewavePassWord(self, request, context):
        try:
            self.logger.info("Input X stage sinewave injection password:{}".format(request.x_pass_word))
            self.got_passwdx = request.x_pass_word
            self.correct_passwdx = (request.x_pass_word == 911911911)
            return saxcs_diagnostic_pb2.ResultReply(result_succeed = self.correct_passwdx)
        except grpc.RpcError as e:
            raise e

    def YSinewavePassWord(self, request, context):
        try:
            self.logger.info("Input Y stage sinewave injection password:{}".format(request.y_pass_word))
            self.got_passwdy = request.y_pass_word
            self.correct_passwdy = (request.y_pass_word == 911911911)
            return saxcs_diagnostic_pb2.ResultReply(result_succeed = self.correct_passwdy)
        except grpc.RpcError as e:
            raise e

    def StartTuningX(self, request, context):
        '''
        Core code: Move stage to target position and inject sinewave
        '''
        try:
            self.logger.debug("X sinwave set correctly:{0}, Stage position set correctly:{1}, BalanceX feedforward gain set correctly:{2}, X sinewave parameters set correctly:{3}".format(self.correct_passwdx, self.xypos_set, self.xffdgain_set, self.xsinewave_set))
            if (self.correct_passwdx and self.xypos_set and self.xffdgain_set and self.xsinewave_set):
                self.logger.info("Start tuning Balance X")
                bounds = SAXCS_SetpointBounds(0.1, 1, 1, 8)
                self.upss_diag.config_x_sine(EnableSineU=False)
                self.logger.debug("Reset X sinewave injection configuration")
                self.upss_diag.config_y_sine(EnableSineVrw=False)
                self.logger.debug("Reset Y sinewave injection configuration")
                self.upss_diag.balancexy.Tuning.TuningBalanceFfwd.BalanceParamsX.BalanceForceGain_Back.value = self.xinitial_gain
                self.upss_diag.balancexy.Tuning.TuningBalanceFfwd.BalanceParamsX.BalanceForceGain_Front.value = self.xinitial_gain
                self.logger.debug("Set Balance X gain to initial gain")
                self.upss_diag.enable_balance(EnableBalanceXY=False, EnableBalanceRxRy=False)
                self.upss_diag.stage.Initialize()
                self.logger.info("Initialize the stage")
                self.upss_diag.enable_balance(EnableBalanceXY=True, EnableBalanceRxRy=True)
                self.logger.info("Enabled Balance XY")
                self.upss_diag.stage.MoveAbsolute(self.XPos, self.YPos, bounds, bounds)
                self.logger.info("Move stage to target position")
                time.sleep(4)
                with TraceFromScope(name=self.file_name+'Tuning_Balance_X',
                                path=self.path,
                                signals=self.signals,
                                file_mode=TraceFromScope.FileMode.PREFIX_TIMESTAMP
                                ) as trace:
                    xfilename = trace.filename
                    self.logger.info("Start tuning...")
                    self.upss_diag.config_x_sine(EnableSineU=True, 
                                                FreqU=self.FreqU, 
                                                AmpU=self.AmpU, 
                                                RisingSlewRate=self.RisingSlewRateU,
                                                Passwd=self.got_passwdx)
                    self.logger.info("Enable sinewave injection")
                    time.sleep(self.AmpU/self.RisingSlewRateU + 5)
                    self.logger.info("Wait for the amplitude achieve the target value")
                    CurrentGain = self.xinitial_gain
                    while CurrentGain < self.xmax_gain:
                        self.logger.debug("CurrentGain={}".format(CurrentGain))
                        time.sleep(self.holdtime)
                        CurrentGain = CurrentGain + self.xgain_step
                        self.upss_diag.balancexy.Tuning.TuningBalanceFfwd.BalanceParamsX.BalanceForceGain_Back.value = CurrentGain
                        self.upss_diag.balancexy.Tuning.TuningBalanceFfwd.BalanceParamsX.BalanceForceGain_Front.value = CurrentGain
                    time.sleep(self.holdtime + 5)
                    trace.stop()
                self.logger.debug("Log file name:{}".format(xfilename))
                self.upss_diag.config_x_sine(EnableSineU=False, 
                                            FreqU=self.FreqU, 
                                            AmpU=self.AmpU, 
                                            RisingSlewRate=self.RisingSlewRateU,
                                            Passwd=self.got_passwdx)
                self.logger.info("Disable X stage sinewave injection")
                time.sleep(self.AmpU/self.RisingSlewRateU + 5)
                self.logger.info("Wait for the amplitude back to 0")
                self.upss_diag.enable_balance(EnableBalanceXY=False, EnableBalanceRxRy=False)
                self.logger.info("Disable balance XY and balance RxRy")
                self.upss_diag.stage.Terminate()
                self.logger.info("Terminate stage")
                self.CleanMark()
                self.logger.debug("File md5 calculate:{}".format(self.file_md5(xfilename)))
                return saxcs_diagnostic_pb2.FileResultReply(result_succeed = True,
                                                            flie_name = xfilename,
                                                            file_md5 = self.file_md5(xfilename))       # Finished tuning balance X
            else:
                return saxcs_diagnostic_pb2.FileResultReply(result_succeed = False)
        except grpc.RpcError as e:
            raise e
    ######################## Tuning Balance Y ############################
    def SetYSinewave(self, request, context):
        '''
        Check the input parameters and set sinewave frequency and amplitude
        :YSinewaveFreq: The frequency of Y stage sinewave
        :YSinewaveAmp: The amplitude of Y stage sinewave
        '''
        try:
            self.logger.info("Setting Y stage sinewave parameters")
            if self.ParametersCheck(1, request.y_sinewave_amp, request.y_sinewave_freq):
                return saxcs_diagnostic_pb2.ResultReply(result_succeed = self.ysinewave_set)
        except grpc.RpcError as e:
            raise e
    
    def SetYFFDGain(self, request, context):
        try:
            self.logger.info("Setting Y feedforward gain parameters")
            self.yinitial_gain = request.y_initial_gain
            self.ymax_gain = request.y_max_gain
            self.ygain_step = request.y_gain_step
            self.yffdgain_set = True
            return saxcs_diagnostic_pb2.ResultReply(result_succeed = True)
        except grpc.RpcError as e:
            raise e
    
    def SetYBestGain(self, request, context):
        '''
        Set the best gain of current tuning
        : request.YBestGain: The best gain can be used when the apply button pushed
        TODO: The best gain need to save in firmware(Startup software)
        '''
        try:
            self.logger.info("Setting balance Y best feedforward gain")
            self.upss_diag.balancexy.Tuning.TuningBalanceFfwd.BalanceParamsY.BalanceForceGain_Left.value = request.y_best_gain
            self.upss_diag.balancexy.Tuning.TuningBalanceFfwd.BalanceParamsY.BalanceForceGain_Right.value = request.y_best_gain
            self.logger.debug("BalanceYGain={}".format(request.y_best_gain))
            return saxcs_diagnostic_pb2.ResultReply(result_succeed = True)
        except grpc.RpcError as e:
            raise e

    def StartTuningY(self, request, context):
        '''
        Core code: Move stage to target position and inject sinewave
        '''
        try:
            self.logger.debug("Y sinwave set correctly:{0}, Stage position set correctly:{1}, BalanceY feedforward gain set correctly:{2}, Y sinewave parameters set correctly:{3}".format(self.correct_passwdy, self.xypos_set, self.yffdgain_set, self.ysinewave_set))
            if (self.correct_passwdy and self.xypos_set and self.yffdgain_set and self.ysinewave_set):
                self.logger.info("Start tuning balance Y")
                bounds = SAXCS_SetpointBounds(0.1, 1, 1, 8)
                self.upss_diag.config_x_sine(EnableSineU=False)
                self.upss_diag.config_y_sine(EnableSineVrw=False)
                self.logger.info("Disable sinewave injection")
                self.upss_diag.stage.Reset(ResetMode=Stage_ResetMode.ClearAll)
                self.logger.info("Reset stage(Clear all)")
                self.upss_diag.balancexy.Tuning.TuningBalanceFfwd.BalanceParamsY.BalanceForceGain_Left.value = self.yinitial_gain
                self.upss_diag.balancexy.Tuning.TuningBalanceFfwd.BalanceParamsY.BalanceForceGain_Right.value = self.yinitial_gain
                self.logger.info("Set balance initial gain to {}".format(self.yinitial_gain))
                self.upss_diag.enable_balance(EnableBalanceXY=False, EnableBalanceRxRy=False)
                self.upss_diag.stage.Initialize()
                self.logger.info("Initilaize stage")
                self.upss_diag.enable_balance(EnableBalanceXY=True, EnableBalanceRxRy=True)
                self.logger.debug("Enbale balance")
                self.upss_diag.stage.MoveAbsolute(self.XPos, self.YPos, bounds, bounds)
                time.sleep(4)
                with TraceFromScope(name=self.file_name+'Tuning_Balance_Y',
                                signals=self.signals,
                                path=self.path,
                                file_mode=TraceFromScope.FileMode.PREFIX_TIMESTAMP
                                ) as trace:
                    self.logger.debug("Stop logging.")
                    yfilename = trace.filename
                    self.logger.info("Start tuning balance Y")
                    self.upss_diag.config_y_sine(EnableSineVrw=True,
                                                 FreqVrw=self.FreqV,
                                                 AmpVrw=self.AmpV,
                                                 RisingSlewRate=self.RisingSlewRateV,
                                                 Passwd=self.got_passwdy)
                    time.sleep(self.AmpV/self.RisingSlewRateV + 5)
                    CurrentGain = self.yinitial_gain
                    while CurrentGain < self.ymax_gain:
                        self.logger.debug("Current gain value is {}".format(CurrentGain))
                        time.sleep(self.holdtime)
                        CurrentGain = CurrentGain + self.ygain_step
                        self.upss_diag.balancexy.Tuning.TuningBalanceFfwd.BalanceParamsY.BalanceForceGain_Left.value = CurrentGain
                        self.upss_diag.balancexy.Tuning.TuningBalanceFfwd.BalanceParamsY.BalanceForceGain_Right.value = CurrentGain
                    time.sleep(self.holdtime + 5)
                    trace.stop()
                self.logger.info("Finished tuning, terminating system.")
                self.upss_diag.config_y_sine(EnableSineVrw=False,
                                             FreqVrw=self.FreqV,
                                             AmpVrw=self.AmpV,
                                             RisingSlewRate=self.RisingSlewRateV,
                                             Passwd=self.got_passwdy)
                self.logger.info("Disabling sinewave injection")
                time.sleep(self.AmpV/self.RisingSlewRateV + 5)
                self.upss_diag.enable_balance(EnableBalanceXY=False, EnableBalanceRxRy=False)
                self.upss_diag.stage.Terminate()
                self.CleanMark()
                self.logger.debug("File md5:{}".format(self.file_md5(yfilename)))
                return saxcs_diagnostic_pb2.FileResultReply(result_succeed = True,
                                                            flie_name = yfilename,
                                                            file_md5 = self.file_md5(yfilename))       # Finished tuning balance X
            else:
                return saxcs_diagnostic_pb2.FileResultReply(result_succeed = False)
        except grpc.RpcError as e:
            raise e
    ###################### Tuning balance Rx ###############################
    def SetRxFFDGain(self, request, context):
        '''
        SetFeedforward gain range for tuning
        : request.rx_initial_gain: Set Balance Rx tuning first gain
        : request.rx_max_gain: Set the feedforward gain maximum value
        : request.rx_gain_step: Set the tuning gain setp of balance Rx
        '''
        try:
            self.logger.info("Setting balance rx feedforward gain parameters")
            self.rxinitial_gain = request.rx_initial_gain
            self.rxmax_gain = request.rx_max_gain
            self.rxgain_step = request.rx_gain_step
            self.rxffdgain_set = True
            return saxcs_diagnostic_pb2.ResultReply(result_succeed = self.rxffdgain_set)
        except grpc.RpcError as e:
            raise e

    def SetRxBestGain(self, request, context):
        '''
        Set the best gain of current tuning
        : request.set_rx_front_gain: The best gain can be apply to firmware and the best gain is front motors.
        Back motors gain will be applied if request.SetRxFrontGainApply
        : request.rx_best_gain: The best gain value
        '''
        try:
            self.logger.info("Set balance rx gain")
            if request.set_rx_front_gain == False:
                self.logger.info("Set balance rx Back motors feedforward gain")
                self.upss_diag.balancerxry.Tuning.TuningBalanceFfwd.BalanceParamsRx.BalanceForceGain_LeftBack.value = request.rx_best_gain
                self.upss_diag.balancerxry.Tuning.TuningBalanceFfwd.BalanceParamsRx.BalanceForceGain_RightBack.value = request.rx_best_gain
                return saxcs_diagnostic_pb2.ResultReply(result_succeed = True)
            else:
                self.logger.info("Set balance rx Front motors feedforward gain")
                self.upss_diag.balancerxry.Tuning.TuningBalanceFfwd.BalanceParamsRx.BalanceForceGain_RightFront.value = request.rx_best_gain
                self.upss_diag.balancerxry.Tuning.TuningBalanceFfwd.BalanceParamsRx.BalanceForceGain_LeftFront.value = request.rx_best_gain
                return saxcs_diagnostic_pb2.ResultReply(result_succeed = True)
        except grpc.RpcError as e:
            raise e
    
    def StartTuningRx(self, request, context):
        '''
        Core code: Move stage to target position and inject sinewave
        '''
        try:
            self.logger.debug("Y sinwave set correctly:{0}, Stage position set correctly:{1}, BalanceRx feedforward gain set correctly:{2}, Y sinewave parameters set correctly:{3}".format(self.correct_passwdy, self.xypos_set, self.rxffdgain_set, self.ysinewave_set))
            if (self.correct_passwdy and self.xypos_set and self.rxffdgain_set and self.ysinewave_set):
                self.logger.info("Start tuning")
                bounds = SAXCS_SetpointBounds(0.1, 1, 1, 8)
                self.upss_diag.config_x_sine(EnableSineU=False)
                self.upss_diag.config_y_sine(EnableSineVrw=False)
                self.upss_diag.enable_balance(EnableBalanceXY=False, EnableBalanceRxRy=False)
                self.upss_diag.stage.Reset(ResetMode=Stage_ResetMode.ClearAll)
                self.logger.debug("Initializing stage")
                self.upss_diag.stage.Initialize()
                # Set balance initial gain, only set the tuned gain. another gain can be changed.
                if request.start_rx_front_tuning == True:
                    self.logger.debug("Initialize balance rx Front motors feedforward gain")
                    self.upss_diag.balancerxry.Tuning.TuningBalanceFfwd.BalanceParamsRx.BalanceForceGain_LeftFront.value = self.rxinitial_gain
                    self.upss_diag.balancerxry.Tuning.TuningBalanceFfwd.BalanceParamsRx.BalanceForceGain_RightFront.value = self.rxinitial_gain
                else:
                    self.logger.debug("Initialize balance rx Back motors feedforward gain")
                    self.upss_diag.balancerxry.Tuning.TuningBalanceFfwd.BalanceParamsRx.BalanceForceGain_LeftBack.value = self.rxinitial_gain
                    self.upss_diag.balancerxry.Tuning.TuningBalanceFfwd.BalanceParamsRx.BalanceForceGain_RightBack.value = self.rxinitial_gain
                self.logger.info("Enabling balance")
                self.upss_diag.enable_balance(EnableBalanceXY=True, EnableBalanceRxRy=True)
                self.logger.info("Move stage to target position")
                self.upss_diag.stage.MoveAbsolute(self.XPos, self.YPos, bounds, bounds)
                time.sleep(4)
                with TraceFromScope(name=self.file_name+'Tuning_Balance_Rx',
                                signals=self.signals,
                                path=self.path,
                                file_mode=TraceFromScope.FileMode.PREFIX_TIMESTAMP
                                ) as trace:
                    rxfile_name = trace.filename
                    self.logger.info("Y stage sinewave injection")
                    self.upss_diag.config_y_sine(EnableSineVrw=True, 
                                                FreqVrw=self.FreqV, 
                                                AmpVrw=self.AmpV, 
                                                RisingSlewRate=self.RisingSlewRateV,
                                                Passwd=self.got_passwdy)
                    time.sleep(self.AmpV/self.RisingSlewRateV + 5)
                    self.logger.info("Start tuning")
                    CurrentGain = self.rxinitial_gain
                    while CurrentGain < self.rxmax_gain:
                        time.sleep(self.holdtime)
                        self.logger.debug("Balance Rx current gain: {}".format(CurrentGain))
                        CurrentGain = CurrentGain + self.rxgain_step
                        if request.start_rx_front_tuning == True:
                            self.logger.debug("Balance Rx Front motor gain: {}".format(CurrentGain))
                            self.upss_diag.balancerxry.Tuning.TuningBalanceFfwd.BalanceParamsRx.BalanceForceGain_LeftFront.value = CurrentGain
                            self.upss_diag.balancerxry.Tuning.TuningBalanceFfwd.BalanceParamsRx.BalanceForceGain_RightFront.value = CurrentGain
                        else:
                            self.logger.debug("Balance Rx Back motor gain: {}".format(CurrentGain))
                            self.upss_diag.balancerxry.Tuning.TuningBalanceFfwd.BalanceParamsRx.BalanceForceGain_LeftBack.value = CurrentGain
                            self.upss_diag.balancerxry.Tuning.TuningBalanceFfwd.BalanceParamsRx.BalanceForceGain_RightBack.value = CurrentGain
                    time.sleep(self.holdtime + 5)
                    trace.stop()
                self.logger.info("Stop Tuning")
                self.upss_diag.config_y_sine(EnableSineVrw=False, 
                                            FreqVrw=self.FreqV, 
                                            AmpVrw=self.AmpV, 
                                            RisingSlewRate=self.RisingSlewRateV,
                                            Passwd=self.got_passwdy)
                time.sleep(self.AmpV/self.RisingSlewRateV + 5)
                self.logger.info("Disable sinewave injection")
                self.upss_diag.enable_balance(EnableBalanceXY=False, EnableBalanceRxRy=False)
                self.logger.info("Terminating stage")
                self.upss_diag.stage.Terminate()
                self.CleanMark()
                return saxcs_diagnostic_pb2.FileResultReply(result_succeed = True,
                                                            flie_name = rxfile_name,
                                                            file_md5 = self.file_md5(rxfile_name))       # Finished tuning balance X
            else:
                return saxcs_diagnostic_pb2.FileResultReply(result_succeed = False)
        except grpc.RpcError as e:
            raise e
    ##################### Tuning Balance Ry ################################
    def SetRyFFDGain(self, request, context):
        '''
        Function: Set the gain settings for tuning
        : request.ry_initial_gain Set the initial gain of balance Ry tuning;
        : request.ry_max_gain: Set the max gain of Ry tuning
        : request.ry_gain_step: Set the step of gain tuining
        '''
        self.ryffdgain = False
        try:
            self.logger.info("Setting balance ry feedforward gain")
            self.ryinitial_gain = request.ry_initial_gain
            self.rymax_gain = request.ry_max_gain
            self.rygain_step = request.ry_gain_step
            self.ryffdgain = True
            return saxcs_diagnostic_pb2.ResultReply(result_succeed = True)
        except grpc.RpcError as e:
            raise e
    
    def SetRyBestGain(self, request, context):
        '''
        Set the best gain of current tuning
        : request.set_ry_left_gain: Start left motors gain tuning when set_ry_left_gain is true. Start right motors when set_ry_left_gain is false
        : request.ry_best_gain: The best gain value
        '''
        try:
            self.logger.info("Setting balance ry gain")
            if request.set_ry_left_gain == True:
                self.logger.debug("Set balance ry Left motors gain")
                self.upss_diag.balancerxry.Tuning.TuningBalanceFfwd.BalanceParamsRy.BalanceForceGain_LeftBack.value = request.ry_best_gain
                self.upss_diag.balancerxry.Tuning.TuningBalanceFfwd.BalanceParamsRy.BalanceForceGain_LeftFront.value = request.ry_best_gain
                return saxcs_diagnostic_pb2.ResultReply(result_succeed = True)
            else:
                self.logger.debug("Set balance ry Right motors gain")
                self.upss_diag.balancerxry.Tuning.TuningBalanceFfwd.BalanceParamsRy.BalanceForceGain_RightBack.value = request.ry_best_gain
                self.upss_diag.balancerxry.Tuning.TuningBalanceFfwd.BalanceParamsRy.BalanceForceGain_RightFront.value = request.ry_best_gain
                return saxcs_diagnostic_pb2.ResultReply(result_succeed = True)
        except grpc.RpcError as e:
            raise e
    
    def StartTuningRy(self, request, context):
        '''
        Core code: Move stage to target position and inject sinewave
        '''
        try:
            self.logger.debug("BalanceRy Tuning: X sinwave set correctly:{0}, Stage position set correctly:{1}, BalanceRy feedforward gain set correctly:{2}, X sinewave parameters set correctly:{3}".format(self.correct_passwdx, self.xypos_set, self.xffdgain_set, self.xsinewave_set))
            if (self.correct_passwdx and self.xypos_set and self.ryffdgain and self.xsinewave_set):
                self.logger.info("Start tuning balance ry")
                bounds = SAXCS_SetpointBounds(0.1, 1, 1, 8)
                self.upss_diag.config_x_sine(EnableSineU=False)
                self.upss_diag.config_y_sine(EnableSineVrw=False)
                self.upss_diag.enable_balance(EnableBalanceXY=False, EnableBalanceRxRy=False)
                self.upss_diag.stage.Reset(ResetMode=Stage_ResetMode.ClearAll)
                self.logger.info("Disabled sinewave")
                self.upss_diag.stage.Initialize()
                self.logger.info("Stage initialized")
                # Set balance initial gain, only set the tuned gain. another gain can be changed.
                if request.start_ry_left_tuning == True:
                    self.logger.debug("Setting balance ry left motors initial gain")
                    self.upss_diag.balancerxry.Tuning.TuningBalanceFfwd.BalanceParamsRy.BalanceForceGain_LeftFront.value = self.ryinitial_gain
                    self.upss_diag.balancerxry.Tuning.TuningBalanceFfwd.BalanceParamsRy.BalanceForceGain_LeftBack.value = self.ryinitial_gain
                else:
                    self.logger.debug("Setting balance ry right motors initial gain")
                    self.upss_diag.balancerxry.Tuning.TuningBalanceFfwd.BalanceParamsRy.BalanceForceGain_RightFront.value = self.ryinitial_gain
                    self.upss_diag.balancerxry.Tuning.TuningBalanceFfwd.BalanceParamsRy.BalanceForceGain_RightBack.value = self.ryinitial_gain
                self.upss_diag.enable_balance(EnableBalanceXY=True, EnableBalanceRxRy=True)
                self.logger.info("Enabled Balance")
                self.upss_diag.stage.MoveAbsolute(self.XPos, self.YPos, bounds, bounds)
                self.logger.info("Moved stage to target position")

                time.sleep(4)
                with TraceFromScope(name=self.file_name+'Tuning_Balance_Ry',
                                signals=self.signals,
                                path=self.path,
                                file_mode=TraceFromScope.FileMode.PREFIX_TIMESTAMP
                                ) as trace:
                    ryfilename = trace.filename
                    self.logger.info("Start tuning balance ry")
                    self.upss_diag.config_x_sine(EnableSineU=True, 
                                                FreqU=self.FreqU, 
                                                AmpU=self.AmpU, 
                                                RisingSlewRate=self.RisingSlewRateU,
                                                Passwd=self.got_passwdx)
                    self.logger.info("X stage sinewave injection")
                    time.sleep(self.AmpU/self.RisingSlewRateU + 5)
                    CurrentGain = self.ryinitial_gain
                    while CurrentGain < self.rymax_gain:
                        time.sleep(self.holdtime)
                        CurrentGain = CurrentGain + self.rygain_step
                        self.logger.info("Tuning balance ry current gain: {}".format(CurrentGain))
                        if request.start_ry_left_tuning == True:
                            self.logger.debug("Balance Ry Left motors gain:{}".format(CurrentGain))
                            self.upss_diag.balancerxry.Tuning.TuningBalanceFfwd.BalanceParamsRy.BalanceForceGain_LeftFront.value = CurrentGain
                            self.upss_diag.balancerxry.Tuning.TuningBalanceFfwd.BalanceParamsRy.BalanceForceGain_LeftBack.value = CurrentGain
                        else:
                            self.logger.debug("Balance Ry Right motors gain:{}".format(CurrentGain))
                            self.upss_diag.balancerxry.Tuning.TuningBalanceFfwd.BalanceParamsRy.BalanceForceGain_RightFront.value = CurrentGain
                            self.upss_diag.balancerxry.Tuning.TuningBalanceFfwd.BalanceParamsRy.BalanceForceGain_RightBack.value = CurrentGain
                    time.sleep(self.holdtime + 5)
                    trace.stop()
                self.logger.info("Stop tuning balance Ry")
                self.upss_diag.config_x_sine(EnableSineU=False, 
                                            FreqU=self.FreqU, 
                                            AmpU=self.AmpU, 
                                            RisingSlewRate=self.RisingSlewRateU,
                                            Passwd=self.got_passwdx)
                time.sleep(self.AmpU/self.RisingSlewRateU + 5)
                self.upss_diag.enable_balance(EnableBalanceXY=False, EnableBalanceRxRy=False)
                self.upss_diag.stage.Terminate()
                self.logger.info("Terminate system")
                self.CleanMark()
                return saxcs_diagnostic_pb2.FileResultReply(result_succeed = True,
                                                            flie_name = ryfilename,
                                                            file_md5 = self.file_md5(ryfilename))       # Finished tuning balance X
            else:
                return saxcs_diagnostic_pb2.FileResultReply(result_succeed = False)
        except grpc.RpcError as e:
            raise e
    ######################### Stage X Control #################################
    def EnableStageX(self, request, context):
        '''
        Enable stage X in current position
        Disabled = 0 :      Module not initialized, all controllers and Actuators are disabled
        Error = 1:          An error occurred. The module needs to be reset before continuing
        DiagnosticMode = 2: Module is in diagnostic mode, enabling low level test interfaces
        Initializing = 3:   Module is being initialized; Motion controller is enabled, homing sequence performed if necessary and then moved to initialize position
        Terminating = 4:    Module is being terminated; Module is moved to terminate position, then motion controller is disabled
        Aborting = 5        The active command is being aborted 
        Disabling = 6       Module is being disabled. 
        Enabling = 7        Module is being enabled
        Ready = 8           Module is enabled and ready for a new (motion) command
        Moving = 9          Module is executing a motion command
        Stopping = 10       The active motion command is being stopped
        '''
        try:
            self.logger.info("Enabling stage X")
            self.upss_diag.stage.U.Enable()
            return saxcs_diagnostic_pb2.StageStateReply(state = int(self.upss_diag.stage.U.Monitor.State.value))
        except grpc.RpcError as e:
            raise e
 
    def DisableStageX(self, request, context):
        try:
            self.logger.info("Disabling stage X")
            self.upss_diag.stage.U.Disable()
            return saxcs_diagnostic_pb2.StageStateReply(state = int(self.upss_diag.stage.U.Monitor.State.value))
        except grpc.RpcError as e:
            raise e
 
    def InitializeXStage(self, request, context):
        '''
        Initialize Stage U. Return stage U status.
        '''
        try:
            self.logger.info("Initialzie stage X")
            self.upss_diag.stage.U.Initialize()
            return saxcs_diagnostic_pb2.StageStateReply(state = int(self.upss_diag.stage.U.Monitor.State.value))
        except grpc.RpcError as e:
            raise e
 
    def TerminateXStage(self, request, context):
        '''
        Terminate X Stage. Move to terminate position and disable.
        '''
        try:
            self.logger.info("Terminate stage X")
            self.upss_diag.stage.U.Terminate()
            return saxcs_diagnostic_pb2.StageStateReply(state = int(self.upss_diag.stage.U.Monitor.State.value))
        except grpc.RpcError as e:
            raise e

    def MoveXAbsolute(self, request, context):
        '''
        Function: Move X stage to an absolute position
        '''
        try:
            self.logger.info("Move stage X to {}".format(request.x_target_pos))
            self.upss_diag.stage.U.MoveAbsolute(request.x_target_pos, request.x_velocity, request.x_acceleration, request.x_deceleration, request.x_jerk)
            return saxcs_diagnostic_pb2.StageStateReply(state = int(self.upss_diag.stage.U.Monitor.State.value))
        except grpc.RpcError as e:
            raise e
    def MoveXRelative(self, request, context):
        '''
        Stage can move a displacement
        '''
        try:
            self.logger.info("Move stage X {}".format(request.x_target_displacement))
            self.upss_diag.stage.U.MoveRelative(request.x_target_displacement, request.x_velocity, request.x_acceleration, request.x_deceleration, request.x_jerk)
            return saxcs_diagnostic_pb2.StageStateReply(state = int(self.upss_diag.stage.U.Monitor.State.value))
        except grpc.RpcError as e:
            raise e

    def ResetXStage(self, request, context):
        try:
            self.logger.info("Reseting stage X")
            self.upss_diag.stage.U.Reset(ResetMode=Stage_ResetMode.ClearAll)
            return saxcs_diagnostic_pb2.StageStateReply(state = int(self.upss_diag.stage.U.Monitor.State.value))
        except grpc.RpcError as e:
            raise e
    ######################### Stage Y Control #################################
    def EnableStageY(self, request, context):
        try:
            self.logger.info("Enabling stage Y")
            self.upss_diag.stage.VRw.Enable()
            return saxcs_diagnostic_pb2.StageStateReply(state = int(self.upss_diag.stage.VRw.Monitor.State.value))
        except grpc.RpcError as e:
            raise e
    
    def DisableStageY(self, request, context):
        try:
            self.logger.info("Disabling stage Y")
            self.upss_diag.stage.VRw.Disable()
            return saxcs_diagnostic_pb2.StageStateReply(state = int(self.upss_diag.stage.VRw.Monitor.State.value))
        except grpc.RpcError as e:
            raise e
    
    def InitializeYStage(self, request, context):
        '''
        Initialize Stage V
        '''
        try:
            self.logger.info("Initialzing Stage Y")
            self.upss_diag.stage.VRw.Initialize()
            return saxcs_diagnostic_pb2.StageStateReply(state = int(self.upss_diag.stage.VRw.Monitor.State.value))
        except grpc.RpcError as e:
            raise e

    def TerminateYStage(self, request, context):
        try:
            self.logger.info("Terminating stage Y")
            self.upss_diag.stage.VRw.Terminate()
            return saxcs_diagnostic_pb2.StageStateReply(state = int(self.upss_diag.stage.VRw.Monitor.State.value))
        except grpc.RpcError as e:
            raise e

    def MoveYAbsolute(self, request, context):
        try:
            self.logger.info("Move Y stage to {}".format(request.y_target_pos))
            self.upss_diag.stage.VRw.MoveAbsolute(request.y_target_pos, request.y_velocity, request.y_acceleration, request.y_deceleration, request.y_jerk)
            return saxcs_diagnostic_pb2.StageStateReply(state = int(self.upss_diag.stage.VRw.Monitor.State.value))
        except grpc.RpcError as e:
            raise e

    def MoveYRelative(self, request, context):
        try:
            self.logger.info("Move stage Y {}".format(request.y_target_displacement))
            self.upss_diag.stage.VRw.MoveRelative(request.y_target_displacement, request.y_velocity, request.y_acceleration, request.y_deceleration, request.y_jerk)
            return saxcs_diagnostic_pb2.StageStateReply(state = int(self.upss_diag.stage.VRw.Monitor.State.value))
        except grpc.RpcError as e:
            raise e

    def ResetYStage(self, request, context):
        try:
            self.logger.info("Resetting stage Y")
            self.upss_diag.stage.VRw.Reset(ResetMode=StageHbridge_ResetMode.ClearAll)
            return saxcs_diagnostic_pb2.StageStateReply(state = int(self.upss_diag.stage.VRw.Monitor.State.value))
        except grpc.RpcError as e:
            raise e


    ######################### X Mapping #####################################
    def SetXMappingParams(self, request, context):
        '''
        Set the mapping parameters
        '''
        try:
            self.logger.info("Setting Mapping X parameters")
            self.XInitPos = request.x_start_pos
            self.XTargetPos = request.x_end_pos
            self.XStep = request.x_move_step
            self.StayTime = request.hold_time
            self.MoveXParams = {'Velocity': request.x_velocity, 'Acceleration': request.x_acceleration, 'Deceleration': request.x_deceleration, 'Jerk': request.x_jerk}
            self.MappingXParam_Set = True
            return saxcs_diagnostic_pb2.ResultReply(result_succeed = self.MappingXParam_Set)
        except grpc.RpcError as e:
            raise e
        
    def SetXMapValue(self, request, context):
        '''
        Set mapping X matrix
        request.x_mapping_tableï¼šThe mapping value(vector, 41 columns), need to transform to a 36 * 41 matrix
        request.operatiopn_mode: default: "Replace"; 1: "Add"; 2: "Replace"; 3 : "Clear"
        '''
        try:
            self.logger.info("Set X mapping data to mapping table")
            self.VectorXMap = request.x_mapping_table
            Mesh_deltau_Pre = np.zeros([36,41])
            for j in range(36): 
                Mesh_deltau_Pre[j, :] = self.VectorXMap[:]
            MapX_row = np.size(Mesh_deltau_Pre,0)
            MapX_col = np.size(Mesh_deltau_Pre,1)
            self.logger.debug("Mapping x row:{0}, column: {1}".format(MapX_row, MapX_col)) 
            if request.operatiopn_mode == 2:
                self.logger.debug("Add request.x_mapping_table to the Mesh_deltaU")
                self.upss_diag.stage.Tuning.ErrorMap.Mesh_deltaU.value += Mesh_deltau_Pre
            elif request.operatiopn_mode == 3:
                self.logger.debug("Set Mesh_deltaU to 0 matrix")
                self.upss_diag.stage.Tuning.ErrorMap.Mesh_deltaU.value = np.zeros([36,41])
            else:
                self.upss_diag.stage.Tuning.ErrorMap.Mesh_deltaU.value = Mesh_deltau_Pre
            return saxcs_diagnostic_pb2.ResultReply(result_succeed = True)
        except grpc.RpcError as e:
            raise e

    def SetXRzMapValue(self, request, context):
        '''
        x_rz_mapping_table:Set mapping Rz based x direction
        request.operatiopn_mode: default: "Replace"; 1: "Add"; 2: "Replace"; 3 : "Clear"
        '''
        try:
            self.logger.info("Set Rz mapping data to mapping table")
            self.VectorXMap = request.x_rz_mapping_table
            Mesh_deltarz_Pre = np.zeros([36,41])
            for j in range(36): 
                Mesh_deltarz_Pre[j, :] = self.VectorXMap[:]
            MapRz_row = np.size(Mesh_deltarz_Pre,0)
            MapRz_col = np.size(Mesh_deltarz_Pre,1)
            self.logger.debug("Mapping x row:{0}, column: {1}".format(MapRz_row, MapRz_col))
            if request.operatiopn_mode == 2:
                self.logger.debug("Add request.x_rz_mapping_table to the Mesh_deltaRw")
                self.upss_diag.stage.Tuning.ErrorMap.Mesh_deltaRw.value += Mesh_deltarz_Pre
            elif request.operatiopn_mode == 3:
                self.logger.debug("Set Mesh_deltaRw to 0 matrix")
                self.upss_diag.stage.Tuning.ErrorMap.Mesh_deltaRw.value = np.zeros([36,41])
            else:
                self.upss_diag.stage.Tuning.ErrorMap.Mesh_deltaRw.value = Mesh_deltarz_Pre
            return saxcs_diagnostic_pb2.ResultReply(result_succeed = True)
        except grpc.RpcError as e:
            raise e

    def MoveYToTargetPos(self, request, context):
        try:
            self.logger.info("Moving Y stage to target position for mapping X")
            self.upss_diag.stage.Reset(ResetMode=Stage_ResetMode.ClearAll)
            self.logger.debug("Initialize stage Y")
            time.sleep(1)
            self.upss_diag.stage.VRw.Initialize()
            time.sleep(1)
            self.upss_diag.stage.VRw.MoveAbsolute(request.y_ifm_pos, request.y_velocity, request.y_acceleration, request.y_deceleration, request.y_jerk)
            self.MoveYToIFMTar = True
            return saxcs_diagnostic_pb2.ResultReply(result_succeed = self.MoveYToIFMTar)
        except grpc.RpcError as e:
            raise e

    def StartXMapping(self, request, context):
        '''
        Mapping Start: Move stage step by step;
        request.StartMapping: Start mapping when the button pushed
        x
        '''
        try:
            self.logger.info("Start mapping X")
            # For PIL test
            if self.MappingXParam_Set and self.MoveYToIFMTar:
                self.logger.debug("StartXMapping: Initialzie stage U")
                self.upss_diag.stage.U.Initialize()
                time.sleep(1)
                self.upss_diag.stage.U.MoveAbsolute(0, self.MoveXParams['Velocity'], self.MoveXParams['Acceleration'], self.MoveXParams['Deceleration'], self.MoveXParams['Jerk'])
                # Start Mapping
                self.logger.debug("Start mapping")
                with TraceFromScope(name=self.file_name+'_Mapping_X',
                                signals=self.mapping_signal,
                                path=self.path,
                                file_mode=TraceFromScope.FileMode.PREFIX_TIMESTAMP
                                ) as trace:
                    mapxfilename = trace.filename
                    time.sleep(5)
                    CurrentPos = self.XInitPos
                    while CurrentPos <= self.XTargetPos:
                        self.upss_diag.stage.U.MoveAbsolute(CurrentPos, self.MoveXParams['Velocity'], self.MoveXParams['Acceleration'], self.MoveXParams['Deceleration'], self.MoveXParams['Jerk'])
                        time.sleep(self.StayTime)
                        CurrentPos = CurrentPos + self.XStep
                    # Wait for a time to finished.
                    time.sleep(3)
                    trace.stop()
                self.logger.info("Finished Mapping X test, file MD5={}".format(self.file_md5(mapxfilename)))
                self.MappingXParam_Set = False
                self.CleanMark()
                return saxcs_diagnostic_pb2.FileResultReply(result_succeed = True,
                                                        flie_name = mapxfilename,
                                                        file_md5 = self.file_md5(mapxfilename))
            else:
                return saxcs_diagnostic_pb2.FileResultReply(result_succeed = False)
        except grpc.RpcError as e:
            raise e

    def GetXMapTable(self, request, context):
        try:
            self.logger.info("Getting stage X current mapping table")
            TempMapX = self.upss_diag.stage.Tuning.ErrorMap.Mesh_deltaU.value
            XMappingTable = [i for item in TempMapX for i in item]
            return saxcs_diagnostic_pb2.XTableReply(x_map_table = XMappingTable)
        except grpc.RpcError as e:
            raise e
    
    def GetRzMapTable(self, request, context):
        try:
            self.logger.info("Getting stage Rz current mapping table")
            TempMapRz = self.upss_diag.stage.Tuning.ErrorMap.Mesh_deltaRw.value
            RzMappingTable = [i for item in TempMapRz for i in item]
            return saxcs_diagnostic_pb2.RzTableReply(rz_map_table = RzMappingTable)
        except grpc.RpcError as e:
            raise e
    ######################### Y Mapping ##################################
    def SetYMappingParams(self, request, context):
        '''
        Set the mapping parameters
        '''
        try:
            self.logger.info("Setting stage Y mapping parameters")
            self.YInitPos = request.y_start_pos
            self.YTargetPos = request.y_end_pos
            self.YStep = request.y_move_step
            self.StayTime = request.hold_time
            self.MoveYParams = {'Velocity': request.y_velocity, 'Acceleration': request.y_acceleration, 'Deceleration': request.y_deceleration, 'Jerk': request.y_jerk}
            self.MappingYParam_Set = True
            return saxcs_diagnostic_pb2.ResultReply(result_succeed = self.MappingYParam_Set)
        except grpc.RpcError as e:
            raise e
 
    def MoveXToTargetPos(self, request, context):
        '''
        request.YIFMPos
        '''
        try:
            self.logger.info("Moving Y stage to target position for mapping X")
            self.upss_diag.stage.Reset(ResetMode=Stage_ResetMode.ClearAll)
            self.upss_diag.stage.U.Initialize()
            time.sleep(1)
            self.upss_diag.stage.U.MoveAbsolute(request.x_ifm_pos, request.x_velocity, request.x_acceleration, request.x_deceleration, request.x_jerk)
            self.MoveXToIFMTar = True
            return saxcs_diagnostic_pb2.ResultReply(result_succeed = self.MoveXToIFMTar)
        except grpc.RpcError as e:
            raise e

    def SetYRzMapValue(self, request, context):
        '''
        request.y_rz_mapping_table
        request.operatiopn_mode: default: "Replace"; 1: "Add"; 2: "Replace"; 3 : "Clear"
        '''
        try:
            self.logger.info("Set Rz mapping data to mapping table")
            self.VectorYMap = request.y_rz_mapping_table
            Mesh_deltayrz_Pre = np.zeros([36,41])
            for j in range(41): 
                Mesh_deltayrz_Pre[:, j] = self.VectorYMap[:]
            MapRz_row = np.size(Mesh_deltayrz_Pre,0)
            MapRz_col = np.size(Mesh_deltayrz_Pre,1)
            self.logger.debug("Mapping x row:{0}, column: {1}".format(MapRz_row, MapRz_col))
            if request.operatiopn_mode == 2:
                self.logger.debug("Add request.y_rz_mapping_table to the Mesh_deltaRw")
                self.upss_diag.stage.Tuning.ErrorMap.Mesh_deltaRw.value += Mesh_deltayrz_Pre
            elif request.operatiopn_mode == 3:
                self.logger.debug("Set Mesh_deltaRw to 0 matrix")
                self.upss_diag.stage.Tuning.ErrorMap.Mesh_deltaRw.value = np.zeros([36,41])
            else:
                self.upss_diag.stage.Tuning.ErrorMap.Mesh_deltaRw.value = Mesh_deltayrz_Pre
            return saxcs_diagnostic_pb2.ResultReply(result_succeed = True)
        except grpc.RpcError as e:
            raise e
    
    def SetYMapValue(self, request, context):
        '''
        request.y_mapping_table
        request.operatiopn_mode: default: "Replace"; 1: "Add"; 2: "Replace"; 3 : "Clear"
        '''
        try:
            self.logger.info("Set Y mapping data to mapping table")
            self.VectorYMap = request.y_mapping_table
            Mesh_deltay_Pre = np.zeros([36,41])
            for j in range(41): 
                Mesh_deltay_Pre[:, j] = self.VectorYMap[:]
            MapY_row = np.size(Mesh_deltay_Pre,0)
            MapY_col = np.size(Mesh_deltay_Pre,1)
            self.logger.debug("Mapping x row:{0}, column: {1}".format(MapY_row, MapY_col))
            if request.operatiopn_mode == 2:
                self.logger.debug("Add request.y_rz_mapping_table to the Mesh_deltaV")
                self.upss_diag.stage.Tuning.ErrorMap.Mesh_deltaV.value += Mesh_deltay_Pre
            elif request.operatiopn_mode == 3:
                self.logger.debug("Set Mesh_deltaV to 0 matrix")
                self.upss_diag.stage.Tuning.ErrorMap.Mesh_deltaV.value = np.zeros([36,41])
            else:
                self.upss_diag.stage.Tuning.ErrorMap.Mesh_deltaV.value = Mesh_deltay_Pre
            return saxcs_diagnostic_pb2.ResultReply(result_succeed = True)
        except grpc.RpcError as e:
            raise e
 
    def StartYMapping(self, request, context):
        '''
        Mapping Start: Move stage step by step;
        request.StartMapping: Start mapping when the button pushed
        Warning: Make sure stage U was moved to target position !!!!!!!
        '''
        try:
            self.logger.info("Start mapping Y")
            if self.MappingYParam_Set and self.MoveXToIFMTar:
                self.logger.debug("StartXMapping: Initialzie stage U")
                self.upss_diag.stage.VRw.Initialize()
                time.sleep(1)
                self.upss_diag.stage.VRw.MoveAbsolute(0, self.MoveYParams['Velocity'], self.MoveYParams['Acceleration'], self.MoveYParams['Deceleration'], self.MoveYParams['Jerk'])
                self.logger.info("Start mapping")
                with TraceFromScope(name=self.file_name+'_Mapping_Y',
                                signals=self.mapping_signal,
                                path=self.path,
                                file_mode=TraceFromScope.FileMode.PREFIX_TIMESTAMP
                                ) as trace:
                    mapyfilename = trace.filename
                    time.sleep(5)
                    CurrentPos = self.YInitPos
                    while CurrentPos <= self.YTargetPos:
                        self.upss_diag.stage.VRw.MoveAbsolute(CurrentPos, self.MoveYParams['Velocity'], self.MoveYParams['Acceleration'], self.MoveYParams['Deceleration'], self.MoveYParams['Jerk'])
                        time.sleep(self.StayTime)
                        CurrentPos = CurrentPos + self.YStep
                    # Wait for a time to finished.
                    time.sleep(3)
                    trace.stop()
                    
                self.logger.info("Finished Y mapping. And file MD5:{}".format(self.file_md5(mapyfilename)))
                self.MappingYParam_Set = False
                self.CleanMark()
                return saxcs_diagnostic_pb2.FileResultReply(result_succeed = True,
                                                        flie_name = mapyfilename,
                                                        file_md5 = self.file_md5(mapyfilename))
            else:
                return saxcs_diagnostic_pb2.FileResultReply(result_succeed = False)
        except grpc.RpcError as e:
            raise e

    def GetYMapTable(self, request, context):
        try:
            self.logger.info("Getting stage Y current mapping table")
            TempMapY = self.upss_diag.stage.Tuning.ErrorMap.Mesh_deltaV.value
            YMappingTable = [i for item in TempMapY for i in item]
            return saxcs_diagnostic_pb2.YTableReply(y_map_table = YMappingTable)
        except grpc.RpcError as e:
            raise e

    def StopRecord(self, request, context):
        '''
        self.stoprecord
        '''
        try:
            self.logger.info("Stop recording command")
            self.stoprecord = True
            return saxcs_diagnostic_pb2.ResultReply(result_succeed = True)
        except grpc.RpcError as e:
            raise e

    def StartRecord(self, request, context):
        '''
        Function: Record the data based settings
        request.StartRecording: Start record signals when this value is true
        request.StopRecording: Stop recording when this value is true
        request.SampleFrequency: Sample frequency
        request.Duration: Recording time
        request.Signals: List of record signal names
        '''
        try:
            self.logger.info("Start tracing")
            signals = request.signals
            if request.sample_frequency is None:
                freq = 0
            else:
                freq = request.sample_frequency
            if request.duration is None:
                duration = 0.0
            else:
                duration = request.duration
            self.logger.debug("Trace signals:{}".format(request.signals))
            self.logger.debug("Duration={}".format(request.duration))
            with TraceFromScope(name=self.file_name+'_Recording',
                                path=self.path,
                                signals=signals,
                                file_mode=TraceFromScope.FileMode.PREFIX_TIMESTAMP,
                                requested_sample_frequency=freq,
                                duration = duration
                                ) as trace:
                    mapyfilename = trace.filename
                    if (request.duration is None) or (duration == 0):
                        while not self.stoprecord:
                            pass
                        trace.stop()
                    else:
                        time.sleep(duration)
                        trace.stop()
            self.logger.info("Finished record")
            self.stoprecord = False
            return saxcs_diagnostic_pb2.FileResultReply(result_succeed = True,
                                                        flie_name = mapyfilename,
                                                        file_md5 = self.file_md5(mapyfilename))
        except grpc.RpcError as e:
            raise e
 
# gRPC server
if __name__ == '__main__':
    server = grpc.server(futures.ThreadPoolExecutor(max_workers=5))
    saxcs_diagnostic_pb2_grpc.add_SaxcsDiagonsticServicer_to_server(SaxcsDiagonstic(), server)
    server.add_insecure_port("[::]:50051")
    server.start()
    print("grpc server started...")
    server.wait_for_termination()
